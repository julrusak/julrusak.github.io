<!DOCTYPE html>
<html>
<head>
  <title>Julianna Rusakiewicz</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="blog-template.css">
</head>

  <header>
    <h1>JULIANNA RUSAKIEWICZ</h1>
  </header>

  <nav>
    <ul>
      <li><a href="../about.html">About</a></li>
      <li><a href="../resume.html">Resume</a></li>
      <li><a href="blog-index.html">Blog</a></li>
      <li><a href="../connect.html">Connect</a></li>
    </ul>

  </nav>

<main>
  <h1>Object Oriented Programming</h1>
  <h2>Just getting some closure</h2>
  <h4>July 24, 2015</h4>

  <section>
    <p>
      Referred to as closures in computer programming, Blocks, Procs, and lambdas are very powerful when used in Ruby. Simply put, they are ways of grouping code that we want to run. Let us start with the easiest, blocks.
    </p>

  <h3>Blocks</h3>

    <p>
      Blocks are useful for repeating code and can be written two ways depending on how much code you need repeated. You can either use {} for a single line of code, or the word do followed bu end with the larger chunk of code in the middle. Example;
      <pre class="ruby">
        array = [1, 2, 3]
          array.each { |value| value + 1 }
        end

        array = [1, 2, 3]
          array.each do |v|
            v + 1
          end
      </pre>
      Both of these will go through each value in your index of numbers and add one to the value. But what if we wanted to use this exact block again and again? Luckily, there are procs!
    </p>

    <h3>Procs</h3>

    <p>
      Procs, or procedures, are objects that you can call as many times as needed. You can also call methods on procs!
      <pre class="ruby">
        array = [1, 2, 3]

        double = Proc.new { |n| p n*2 }

        array.each(double)

        # => [2, 3, 6]
      </pre>
      It's like making a new block and saving it for later! So why would we need anything else?
    </p>

    <h3>Lambdas</h3>

    <p>
      Lambdas are very similar to Procs only they do a few things differently. They check for arguments, and will return an error if there are more or less arguments, and they respond to the return keyword.
      <pre class="ruby">
          lam_test = lambda { |x| puts x }
          lam_test.call
          # => 2

          lam_test.call
          # => ArgumentError: wrong number of arguments (0 for 1)

          lam_test.call(1,2,3)
          # => ArgumentError: wrong number of arguments (3 for 1)
      </pre>
      While lambdas care about this specificity, Procs will return nil for any missing arguments, and ignore additional ones. As for return;
      <pre class="ruby">
        def lambda_test
          lam_test = lambda { return }
          lam.call
          puts "This is a test"
        end

        lambda_test
        # => 'This is a test'
      </pre>
      Return inside of a lambda code will set off any code directly outside of the lambda code.
    </p>
    <p>So use this when needed and you'll find that it will be much easier to write simple, clean code!</p>
    <p>Happy Coding!</p>

  </section>
</main>

<footer>
    <a href="http://facebook.com/julianna.rus"><img src="imgs/facebook.png" alt="facebook" height="25" width="25"></a>
    <a href="http://twitter.com/juliannarusak"><img src="imgs/twitter.png" alt="twitter" height="25" width="25"></a>
    <a href="#"><img src="imgs/rss.png" alt="rss" height="25" width="25"></a>
    <a href="#"><img src="imgs/share.png" alt="share" height="25" width="25"></a>
    <a href="#"><img src="imgs/mail.png" alt="mail" height="25" width="25"></a>

  </footer>
</html>